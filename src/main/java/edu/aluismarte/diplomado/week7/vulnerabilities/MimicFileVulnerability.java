package edu.aluismarte.diplomado.week7.vulnerabilities;

import edu.aluismarte.diplomado.model.week7.UploadFileResponse;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.web.multipart.MultipartFile;

import java.io.ByteArrayInputStream;
import java.io.File;
import java.io.InputStream;
import java.net.URLConnection;
import java.nio.file.Files;
import java.util.Arrays;
import java.util.UUID;

/**
 * Ejemplo donde hago un servicio que sube un archivo peligroso, pero es un script para hacer daño
 *
 * Incluso implementando el Magic Number, esta función tiene una vulnerabilidad latente y no debe usarse en producción
 * La vulnerabilidad radica en la misma función de Magic Type, que si no encuentro usándolo debe retornar NULL y no usar la función vulnerable anterior.
 *
 * @author aluis on 5/8/2022.
 * @see <a href="https://en.wikipedia.org/wiki/List_of_file_signatures">Magic Bytes or Magic numbers of files</a>
 */
public class MimicFileVulnerability {

    public ResponseEntity<UploadFileResponse> uploadFile(MultipartFile multipartFile) {
        int maxSize = 1024 * 1024 * 10; // 10 MB
        if (multipartFile.getSize() > maxSize) {
            return ResponseEntity.status(HttpStatus.EXPECTATION_FAILED).body(new UploadFileResponse("File too big, more than " + maxSize + " bytes", null));
        }
        String extension = null;
        try {
            String contentType = multipartFile.getContentType();
            if (contentType != null) {
                extension = getExtension(contentType);
            } else if (multipartFile.getOriginalFilename() != null) {
                int index = multipartFile.getOriginalFilename().lastIndexOf(".");
                if (index > 0) {
                    extension = multipartFile.getOriginalFilename().substring(index + 1);
                }
            }
            // TODO con esta linea hago la verificación segura
//            extension =  getByMimetype(multipartFile.getBytes());
            if (extension == null) {
                return ResponseEntity.status(HttpStatus.EXPECTATION_FAILED).body(new UploadFileResponse("Cant detect your mimetype", null));
            }
            new File("./uploads/").mkdir();
            File file = new File("./uploads/" + UUID.randomUUID().toString().replaceAll("-", "") + "." + extension);
            Files.copy(multipartFile.getInputStream(), file.toPath());
            return ResponseEntity.status(HttpStatus.OK).body(new UploadFileResponse("Uploaded the file successfully: " + multipartFile.getOriginalFilename(), multipartFile.getSize()));
        } catch (Exception e) {
            return ResponseEntity.status(HttpStatus.EXPECTATION_FAILED).body(new UploadFileResponse("Could not upload the file: " + multipartFile.getOriginalFilename() + "!", null));
        }
    }

    private String getExtension(String mimetype) {
        return switch (mimetype.toLowerCase()) {
            case MediaType.TEXT_PLAIN_VALUE -> ".txt";
            case MediaType.APPLICATION_PDF_VALUE -> ".pdf";
            case MediaType.IMAGE_PNG_VALUE -> ".png";
            case MediaType.IMAGE_JPEG_VALUE -> ".jpg";
            default -> null;
        };
    }

    /**
     * Forma correcta de detectar la extension.
     *
     * @param content Archivo en bytes
     * @return la extensión
     */
    private String getByMimetype(byte[] content) {
        try {
            InputStream inputStream = new ByteArrayInputStream(content);
            String mimetype = URLConnection.guessContentTypeFromStream(inputStream);
            if (mimetype == null) {
                byte[] pdfMimetype = new byte[]{0x0025, 0x0050, 0x0044, 0x0046, 0x002D};
                byte[] mime = Arrays.copyOfRange(content, 0, 4);
                if (Arrays.equals(pdfMimetype, mime)) {
                    mimetype = MediaType.APPLICATION_PDF_VALUE;
                }
                if (mimetype != null) {
                    return getExtension(mimetype);
                }
            }
            return null;
        } catch (Exception ignored) {
            return null;
        }
    }
}
